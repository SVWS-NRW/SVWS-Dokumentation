import{_ as e,y as n,x as t,W as r}from"./plugin-vue_export-helper.68280688.js";const m='{"title":"Mitarbeit am SVWS-Client","description":"","frontmatter":{},"headers":[{"level":2,"title":"git","slug":"git"}],"relativePath":"SVWS-Client/Mitarbeit.md","lastUpdated":1649311654599}',a={},s=r(`<h1 id="mitarbeit-am-svws-client" tabindex="-1">Mitarbeit am SVWS-Client <a class="header-anchor" href="#mitarbeit-am-svws-client" aria-hidden="true">#</a></h1><h2 id="git" tabindex="-1">git <a class="header-anchor" href="#git" aria-hidden="true">#</a></h2><p>Die Entwicklung am Clinet folgt dem Gitflow-Workflow-Modell. Ein Link zur SVWS-weiten Doku kommt noch.</p><p>F\xFCr den Client bedeutet dies, dass der <code>master</code>-Branch nur vom Releasemanager betreut wird, der in unregelm\xE4\xDFigen Abst\xE4nden ein Release zusammenstellt, das anschlie\xDFend zur Ver\xF6ffentlichung bereitsteht.</p><p>Die Entwicklung findet grunds\xE4tzlich im <code>dev</code>-Branch statt und kann f\xFCr kleinere \xC4nderungen, die keine neuen <em>Features</em> hinzuf\xFCgen, genutzt werden. Dies betrifft also in der Regel kleine Bugfixes oder Tippfehler, die keiner gro\xDFen Pr\xFCfung unterzogen werden m\xFCssen.</p><p>Gr\xF6\xDFere \xC4nderungen, z.B. weitere Tabs oder Cards, die auch die Bedienung des Clients \xE4ndern, werden \xFCber <strong>Feature-Branches</strong> eingebracht und mit einem <strong>F</strong> oder <strong>feature</strong> gekennzeichnet. Zum Beispiel <strong>F_Reporting</strong> oder <strong>feature_reporting</strong>. Weitere Branchbezeichnungen w\xE4ren <strong>B_xyz</strong> oder <strong>bug_xyz</strong>.</p><p>Damit der <code>master</code>- und <code>dev</code>-Branch nicht unn\xF6tig mit Merge-Commits \xFCberladen wird, sollten Feature- und andere Branches als Fast-Forward Merger gemergt werden, wenn es sich um eine sinnvolle Entwicklung der Commits handelt oder aber auch als Squash-Commit gemergt werden, wenn viele einzelne Commits genausogut als einer oder wenige Commits zusammengefasst werden k\xF6nnen.</p><p>Wird in einem Feature-Branch gearbeitet ist ein <strong>rebase</strong> vor dem Merge hilfreich, damit keine unn\xF6tigen Commits entstehen. Gleiches gilt f\xFCr Arbeiten am <code>dev</code>-Branch. Bevor eigene \xC4nderungen hochgeladen werden, bitte darauf achten, dass kein Merge n\xF6tig ist. Haben schon \xC4nderungen im lokalen Git-Repository stattgefunden und im <code>origin/dev</code> sind ebenfalls \xC4nderungen eingespielt worden, dann hilft ein <code>git pull --rebase</code>, das die eigenen \xC4nderungen nach dem <code>pull</code> anh\xE4ngt, statt ein Merge erforderlich zu machen.</p><h1 id="npm" tabindex="-1">npm <a class="header-anchor" href="#npm" aria-hidden="true">#</a></h1><p>Nach \xC4nderungen an den <code>package-lock.json</code> muss ein <code>npm i</code> ausgef\xFChrt werden, damit neue Abh\xE4ngigkeiten installiert werden.</p><p>Momentan werden durch den Server und der UI-Bibliothek einige Module nur lokal zur Verf\xFCgung gestellt, die nicht per <a href="http://npm.org" target="_blank" rel="noopener noreferrer">npm.org</a> gefunden werden. Damit npm trotzdem funktioniert, m\xFCssen diese Abh\xE4ngigkeiten lokal hergestellt werden:</p><pre><code>npm link @svws-nrw/svws-openapi-ts @svws-nrw/svws-core-ts @svws-nrw/svws-ui
</code></pre><p>Nach jedem <code>npm i</code> muss dieser Schritt wiederholt werden.</p><h1 id="prettier" tabindex="-1">prettier <a class="header-anchor" href="#prettier" aria-hidden="true">#</a></h1><p>Es gibt eine <code>.prettierrc.json</code>, die das Projekt mit der <em>richtigen</em> Formatierung versorgt. Die meisten Editoren k\xF6nnen \xFCber Erweiterungen diese Formatierungsvorgabe direkt ausf\xFChren, alternativ kann man im Terminal <code>npm run format</code> ausf\xFChren, dann werden automatisch alle Dateien korrigiert. Vor jedem Einchecken des Codes sollte dies ausgef\xFChrt werden.</p><h1 id="eslint" tabindex="-1">eslint <a class="header-anchor" href="#eslint" aria-hidden="true">#</a></h1><p>Ebenso gibt es eine <code>.eslintrc.js</code>, die daf\xFCr sorgt, dass ESLint \xFCber den Code schaut und Fehler sowieso Warnungen ausgibt. Hier biten ebenfalls die meisten Editoren passende Erweiterungen an oder im Terminal kann der Linter mit <code>npm run lint:script</code> gestartet werden. Vor dem Einchecken bittte ebenfalls den neuen Code pr\xFCfen.</p><h1 id="vue" tabindex="-1">vue <a class="header-anchor" href="#vue" aria-hidden="true">#</a></h1><p>Es gibt ein Mixin, das jede Seite mit einem individuellen Titel versorgen kann, dazu die Option <code>title: &quot;Ein Titel&quot;</code> verwenden.</p><h1 id="typescript" tabindex="-1">typescript <a class="header-anchor" href="#typescript" aria-hidden="true">#</a></h1><p>Der Client verwendet Typescript, daher ein paar Konventionen:</p><p>Arrays werden \xFCber den Array-Typ angegeben mit den Type-Parametern:</p><pre><code>Array&lt;string&gt;
</code></pre><p>statt</p><pre><code>string[]
</code></pre><p>Nach M\xF6glichkeit sollen <code>any</code> vermieden werden und die daf\xFCr vorgesehenen Typen verwendet werden. ESLint sp\xFCrt <code>any</code>s auf und meldet sie als Warnung. Wenn es nicht zu vermeiden ist, kann man Ausnahmen bezogen auf einzelne Zeilen oder auch auf Dateiebene verwenden.</p><p>In Klassen sollten alle Variablen und Funktionen nach <code>public</code> und <code>private</code> unterschieden werden. Sollen getter und setter verwendet werden, die auf private Variablen zugreifen und diese \xFCber die eingerichteten setter ver\xE4ndern, wird ein Unterstrich verwendet, damit man diese Variable als getter/setter-Variable zuordnen kann:</p><div class="language-ts"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> _bar<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
  <span class="token keyword">get</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_bar <span class="token punctuation">}</span>
  <span class="token keyword">set</span> <span class="token function">bar</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_bar <span class="token operator">=</span> s <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="editor" tabindex="-1">Editor <a class="header-anchor" href="#editor" aria-hidden="true">#</a></h1><p>F\xFCr die Entwicklung bietet sich VS Code an, die verwendeten Erweiterungen sind im Doku-Repo zu finden.</p><p>Prettier ist auf die Verwendung von Tabs eingestellt. Der Grund ist recht einfach, jeder hat Vorlieben was die Abst\xE4nde der Einr\xFCckungen sind, Tabs lassen sich in der Breite variabel anzeigen. Es spielt also keine Rolle, ob man zwei oder vier Leerzeichen bevorzugt, beides l\xE4sst sich in den individuellen Editoreinstellungen festlegen, ebenso in Gitlab.</p><p><em>Der vim-Modus ist besser als alle anderen Modi\u2026</em></p>`,32),i=[s];function d(o,c,l,p,u,g){return t(),n("div",null,i)}var k=e(a,[["render",d]]);export{m as __pageData,k as default};
